{"version":3,"sources":["dbhelper.js"],"names":["DBHelper","response","status","Promise","resolve","reject","Error","statusText","json","idb","open","upgradeDb","dbPromise","createObjectStore","keyPath","createIndex","store","reviews","offlineFavourites","openDB","then","db","console","log","restaurantsFromDB","objectStore","getAll","fetch","DATABASE_URL","checkStatus","restaurants","saveRestaurants","data","tx","transaction","forEach","restaurant","put","getRestaurantsFromDB","length","getRestaurantsFromAPI","callback","catch","error","find","r","id","cuisine","fetchRestaurants","cuisine_type","results","neighborhood","filter","neighborhoods","map","v","i","uniqueNeighborhoods","indexOf","cuisines","uniqueCuisines","type","google","maps","Marker","position","latlng","title","name","url","urlForRestaurant","animation","Animation","DROP","index","REVIEWS_URL","saveReviews","err","photograph","marker","reviewsFromDB","complete","event","CustomEvent","detail","restaurant_id","document","dispatchEvent","reviewsFromAPI","body","JSON","stringify","headers","Content-Type","parseInt","getParameterByName","Date","getTime","saveReview","requests","iterateCursor","cursor","sendReview","value","delete","getReviewsFromDB","obj","favourite_status","method","sendFavourite","is_favorite","push","continue"],"mappings":"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","file":"dbhelper.js","sourcesContent":["/**\r\n * Common database helper functions.\r\n */\r\nclass DBHelper {\r\n\r\n    /**\r\n     * Database URL.\r\n     * Change this to restaurants.json file location on your server.\r\n     */\r\n    static get DATABASE_URL() {\r\n        const port = 1337 // Change this to your server port\r\n        return `http://localhost:${port}/restaurants`;\r\n    }\r\n\r\n\r\n    /**\r\n     * Reviews URL.\r\n     */\r\n    static get REVIEWS_URL() {\r\n        const port = 1337 // Change this to your server port\r\n        return `http://localhost:${port}/reviews`;\r\n    }\r\n\r\n    /**\r\n     * Check status of Fetch requests.         */\r\n    static checkStatus(response) {\r\n        if (response.status === 200) {\r\n            return Promise.resolve(response)\r\n        } else {\r\n            return Promise.reject(new Error(`Request has failed. Return status: ${response.statusText}`))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert response to JSON data,\r\n     */\r\n    static json(response) {\r\n        return response.json()\r\n    }\r\n\r\n    /**\r\n     * Opens the IndexedDB,\r\n     */\r\n    static openDB() {\r\n        const dbPromise = idb.open('restaurantsDB', 3, upgradeDb => {\r\n            switch (upgradeDb.oldVersion) {\r\n                case 0:\r\n                    const store = upgradeDb.createObjectStore('restaurants', { keyPath: 'id' });\r\n                    store.createIndex('by-id', 'id');\r\n                case 1:\r\n                    const reviews = upgradeDb.createObjectStore('reviews', { keyPath: 'id' });\r\n                    reviews.createIndex('restaurant', 'restaurant_id');\r\n                    const offlineReviews = upgradeDb.createObjectStore('offline_reviews', { keyPath: 'updatedAt' });\r\n                case 2:\r\n                    const offlineFavourites = upgradeDb.createObjectStore('offline_favourites', { keyPath: 'restaurant_id' });\r\n                    offlineFavourites.createIndex('by-restaurant', 'restaurant_id');\r\n            }\r\n        });\r\n        return dbPromise;\r\n    }\r\n\r\n    /**\r\n     * Get the Restaurants from the IDB,\r\n     */\r\n    static getRestaurantsFromDB() {\r\n        const restaurantsFromDB = DBHelper.openDB()\r\n            .then(db => {\r\n                console.log('Getting Restaurants From DB');\r\n                if (!db) return;\r\n                let store = db.transaction('restaurants').objectStore('restaurants');\r\n                return store.getAll();\r\n            });\r\n        return restaurantsFromDB;\r\n    }\r\n\r\n    /**\r\n     * Get the Restaurants from the Server API,\r\n     */\r\n    static getRestaurantsFromAPI() {\r\n        console.log('Getting Restaurants From API');\r\n        const restaurantsFromAPI = fetch(DBHelper.DATABASE_URL)\r\n            .then(DBHelper.checkStatus)\r\n            .then(DBHelper.json)\r\n            .then(restaurants => {\r\n                DBHelper.saveRestaurants(restaurants);\r\n                return restaurants;\r\n            });\r\n        return restaurantsFromAPI;\r\n    }\r\n\r\n    /**\r\n     * Save restaurant-data to IDB,\r\n     */\r\n    static saveRestaurants(data) {\r\n        return DBHelper.openDB().then(db => {\r\n            if (!db) return;\r\n            const tx = db.transaction('restaurants', 'readwrite');\r\n            const store = tx.objectStore('restaurants');\r\n            data.forEach((restaurant) => {\r\n                store.put(restaurant);\r\n            });\r\n            return tx.complete;\r\n        }).then(() => {\r\n            console.log('Restaurants Saved')\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Update restaurant data to IDB.\r\n     */\r\n    static updateRestaurant(data) {\r\n        return DBHelper.openDB().then(db => {\r\n            if (!db) return;\r\n            const tx = db.transaction('restaurants', 'readwrite');\r\n            const store = tx.objectStore('restaurants');\r\n            return store.put(data);\r\n        }).then(() => {\r\n            console.log('Restaurant Updated')\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fetch all restaurants.\r\n     */\r\n    static fetchRestaurants(callback) {\r\n        return DBHelper.getRestaurantsFromDB().then(restaurants => {\r\n            if (restaurants.length) {\r\n                return Promise.resolve(restaurants);\r\n            } else {\r\n                return DBHelper.getRestaurantsFromAPI();\r\n            }\r\n        }).then(restaurants => {\r\n            callback(null, restaurants);\r\n        }).catch(error => {\r\n            callback(error, null);\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Fetch a restaurant by its ID.\r\n     */\r\n    static fetchRestaurantById(id, callback) {\r\n        // fetch all restaurants with proper error handling.\r\n        DBHelper.fetchRestaurants((error, restaurants) => {\r\n            if (error) {\r\n                callback(error, null);\r\n            } else {\r\n                const restaurant = restaurants.find(r => r.id == id);\r\n                if (restaurant) { // Got the restaurant\r\n                    callback(null, restaurant);\r\n                } else { // Restaurant does not exist in the database\r\n                    callback('Restaurant does not exist', null);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fetch restaurants by a cuisine type with proper error handling.\r\n     */\r\n    static fetchRestaurantByCuisine(cuisine, callback) {\r\n        // Fetch all restaurants  with proper error handling\r\n        DBHelper.fetchRestaurants((error, restaurants) => {\r\n            if (error) {\r\n                callback(error, null);\r\n            } else {\r\n                // Filter restaurants to have only given cuisine type\r\n                const results = restaurants.filter(r => r.cuisine_type == cuisine);\r\n                callback(null, results);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fetch restaurants by a neighborhood with proper error handling.\r\n     */\r\n    static fetchRestaurantByNeighborhood(neighborhood, callback) {\r\n        // Fetch all restaurants\r\n        DBHelper.fetchRestaurants((error, restaurants) => {\r\n            if (error) {\r\n                callback(error, null);\r\n            } else {\r\n                // Filter restaurants to have only given neighborhood\r\n                const results = restaurants.filter(r => r.neighborhood == neighborhood);\r\n                callback(null, results);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fetch restaurants by a cuisine and a neighborhood with error handling.\r\n     */\r\n    static fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, callback) {\r\n        // Fetch all restaurants\r\n        DBHelper.fetchRestaurants((error, restaurants) => {\r\n            if (error) {\r\n                callback(error, null);\r\n            } else {\r\n                let results = restaurants\r\n                if (cuisine != 'all') { // filter by cuisine\r\n                    results = results.filter(r => r.cuisine_type == cuisine);\r\n                }\r\n                if (neighborhood != 'all') { // filter by neighborhood\r\n                    results = results.filter(r => r.neighborhood == neighborhood);\r\n                }\r\n                callback(null, results);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fetch all neighborhoods with error handling.\r\n     */\r\n    static fetchNeighborhoods(callback) {\r\n        // Fetch all restaurants\r\n        DBHelper.fetchRestaurants((error, restaurants) => {\r\n            if (error) {\r\n                callback(error, null);\r\n            } else {\r\n                // Get all neighborhoods from all restaurants\r\n                const neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood)\r\n                    // Remove duplicates from neighborhoods\r\n                const uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) == i)\r\n                callback(null, uniqueNeighborhoods);\r\n            }\r\n        });\r\n        DBHelper.fetchReviews((error, reviews) => {\r\n            if (error) {\r\n                callback(error, null);\r\n            } else {\r\n                console.log('Fetch Reviews Success')\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fetch all cuisines with error handling.\r\n     */\r\n    static fetchCuisines(callback) {\r\n        // Fetch all restaurants\r\n        DBHelper.fetchRestaurants((error, restaurants) => {\r\n            if (error) {\r\n                callback(error, null);\r\n            } else {\r\n                // Get all cuisines from all restaurants\r\n                const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type)\r\n                    // Remove duplicates from cuisines\r\n                const uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) == i)\r\n                callback(null, uniqueCuisines);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Restaurant page URL.\r\n     */\r\n    static urlForRestaurant(restaurant) {\r\n        return (`./restaurant.html?id=${restaurant.id}`);\r\n    }\r\n\r\n    // /**\r\n    //  * Restaurant image URL.\r\n    //  */\r\n    // static imageUrlForRestaurant(restaurant) {\r\n    //     return (`/img/${restaurant.photograph}`);\r\n    // }\r\n\r\n    static imageUrlForRestaurant(restaurant, type) {\r\n        if (restaurant.photograph) {\r\n            return `/buildTool/img/${restaurant.id}.jpg`;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map marker for a restaurant.\r\n     */\r\n    static mapMarkerForRestaurant(restaurant, map) {\r\n        const marker = new google.maps.Marker({\r\n            position: restaurant.latlng,\r\n            title: restaurant.name,\r\n            url: DBHelper.urlForRestaurant(restaurant),\r\n            map: map,\r\n            animation: google.maps.Animation.DROP\r\n        });\r\n        return marker;\r\n    }\r\n\r\n    /**\r\n     * Get the Reviews from the IDB.\r\n     */\r\n    static getReviewsFromDB() {\r\n        const reviewsFromDB = DBHelper.openDB()\r\n            .then(db => {\r\n                if (!db) return;\r\n                let store = db.transaction('reviews').objectStore('reviews').index('restaurant');\r\n                return ''; //store.getAll();\r\n            });\r\n        return reviewsFromDB;\r\n    }\r\n\r\n    /**\r\n     * Get the Reviews from the Server API.\r\n     */\r\n    static getReviewsFromAPI() {\r\n        const reviewsFromAPI = fetch(DBHelper.REVIEWS_URL)\r\n            .then(DBHelper.checkStatus)\r\n            .then(DBHelper.json)\r\n            .then(reviews => {\r\n                DBHelper.saveReviews(reviews);\r\n                return reviews;\r\n            });\r\n        return reviewsFromAPI;\r\n    }\r\n\r\n    /**\r\n     * Get the Reviews saved as Offline.\r\n     */\r\n    static checkOfflineReviews() {\r\n        return new Promise((resolve, reject) => {\r\n            DBHelper.openDB().then(db => {\r\n                if (!db) return;\r\n                let store = db.transaction('offline_reviews').objectStore('offline_reviews');\r\n                store.getAll().then(data => {\r\n                    return resolve(data);\r\n                }).catch(err => {\r\n                    reject(err);\r\n                });\r\n            })\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Save Reviews data to IDB.\r\n     */\r\n    static saveReviews(data) {\r\n        return DBHelper.openDB().then(db => {\r\n            if (!db) return;\r\n            const tx = db.transaction('reviews', 'readwrite');\r\n            const store = tx.objectStore('reviews');\r\n            data.forEach((review) => {\r\n                store.put(review);\r\n            });\r\n            return tx.complete;\r\n        }).then(() => {\r\n            console.log('Reviews saved')\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Save Review data to IDB.\r\n     */\r\n    static saveReview(data) {\r\n        return DBHelper.openDB().then(db => {\r\n            if (!db) return;\r\n            const tx = db.transaction('reviews', 'readwrite');\r\n            const store = tx.objectStore('reviews');\r\n            store.put(data);\r\n            return tx.complete;\r\n        }).then(() => {\r\n            console.log('Review saved')\r\n            let event = new CustomEvent(\"update_reviews_list\", { detail: { restaurant_id: data.restaurant_id } });\r\n            document.dispatchEvent(event);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Save Review data to IDB's offline store.\r\n     */\r\n    static saveReviewOffline(data) {\r\n        return DBHelper.openDB().then(db => {\r\n            if (!db) return;\r\n            const tx = db.transaction('offline_reviews', 'readwrite');\r\n            const store = tx.objectStore('offline_reviews');\r\n            store.put(data);\r\n            return tx.complete;\r\n        }).then(() => {\r\n            console.log('Review saved offline')\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Submit the restaurant review to server.\r\n     */\r\n    static sendReview(data) {\r\n        return fetch(DBHelper.REVIEWS_URL, {\r\n                body: JSON.stringify(data),\r\n                headers: {\r\n                    'Accept': 'application/json',\r\n                    'Content-Type': 'application/json'\r\n                },\r\n                method: 'POST',\r\n            })\r\n            .then(response => {\r\n                response.json()\r\n                    .then(data => {\r\n                        data['restaurant_id'] = parseInt(getParameterByName('id'));\r\n                        data['updatedAt'] = new Date().getTime();\r\n                        data['createdAt'] = new Date().getTime();\r\n                        DBHelper.saveReview(data);\r\n                    })\r\n            })\r\n            .catch(error => {\r\n                data['restaurant_id'] = parseInt(getParameterByName('id'));\r\n                data['updatedAt'] = new Date().getTime();\r\n                data['createdAt'] = new Date().getTime();\r\n                DBHelper.saveReviewOffline(data);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Remove Offline Reviews and send them to server.\r\n     */\r\n    static removeOfflineReview(data) {\r\n        return new Promise((resolve, reject) => {\r\n            DBHelper.openDB().then(db => {\r\n                if (!db) return;\r\n                const tx = db.transaction('offline_reviews', 'readwrite');\r\n                const requests = [];\r\n\r\n                tx.objectStore('offline_reviews')\r\n                    .iterateCursor(cursor => {\r\n                        if (!cursor) return;\r\n                        DBHelper.sendReview(cursor.value)\r\n                        requests.push(cursor.value);\r\n                        cursor.delete();\r\n                        cursor.continue();\r\n                    }).then(() => {\r\n                        console.log('Offline review deleted');\r\n                    }).then(() => {\r\n                        return tx.complete;\r\n                    })\r\n            })\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Fetch all reviews.\r\n     */\r\n    static fetchReviews(callback) {\r\n        return DBHelper.getReviewsFromDB().then(reviews => {\r\n            if (reviews.length) {\r\n                return Promise.resolve(reviews);\r\n            } else {\r\n                return DBHelper.getReviewsFromAPI();\r\n            }\r\n        }).then(reviews => {\r\n            callback(null, reviews);\r\n        }).catch(error => {\r\n            callback(error, null);\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Fetch reviews by its ID.\r\n     */\r\n    static fetchReviewByRestaurant(id, callback) {\r\n        return DBHelper.openDB().then(db => {\r\n            return db.transaction('reviews').objectStore('reviews').index('restaurant').getAll(id);\r\n        }).then(obj => {\r\n            return obj\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Save Favourite data to IDB's offline store.\r\n     */\r\n    static saveFavouriteOffline(id, favourite_status) {\r\n        const data = []\r\n        data['restaurant_id'] = parseInt(id);\r\n        data['is_favorite'] = favourite_status;\r\n\r\n        return DBHelper.openDB().then(db => {\r\n            if (!db) return;\r\n            const tx = db.transaction('offline_favourites', 'readwrite');\r\n            const store = tx.objectStore('offline_favourites');\r\n            store.put(data);\r\n            return tx.complete;\r\n        }).then(() => {\r\n            console.log('Like offline')\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Submit the restaurant review to server.\r\n     */\r\n    static sendFavourite(id, favourite_status) {\r\n        let UPDATE_FAV_URL = `${DBHelper.DATABASE_URL}/${id}/?is_favorite=${favourite_status}`\r\n\r\n        return fetch(UPDATE_FAV_URL, {\r\n                method: 'PUT',\r\n            })\r\n            .then(response => {\r\n                response.json()\r\n                    .then(data => {\r\n                        DBHelper.updateRestaurant(data);\r\n                    })\r\n            })\r\n            .catch(error => {\r\n                DBHelper.saveFavouriteOffline(id, favourite_status);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Get the Favourites saved as Offline.\r\n     */\r\n    static checkOfflineFavourites() {\r\n        return new Promise((resolve, reject) => {\r\n            DBHelper.openDB().then(db => {\r\n                if (!db) return;\r\n                let store = db.transaction('offline_favourites').objectStore('offline_favourites');\r\n                store.getAll().then(data => {\r\n                    return resolve(data);\r\n                }).catch(err => {\r\n                    reject(err);\r\n                });\r\n            })\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Remove Offline Favourites and send them to server.\r\n     */\r\n    static removeOfflineFavourite(data) {\r\n        return new Promise((resolve, reject) => {\r\n            DBHelper.openDB().then(db => {\r\n                if (!db) return;\r\n                const tx = db.transaction('offline_favourites', 'readwrite');\r\n                const requests = [];\r\n\r\n                tx.objectStore('offline_favourites')\r\n                    .iterateCursor(cursor => {\r\n                        if (!cursor) return;\r\n                        DBHelper.sendFavourite(cursor.value.restaurant_id, cursor.value.is_favorite)\r\n                        requests.push(cursor.value);\r\n                        cursor.delete();\r\n                        cursor.continue();\r\n                    }).then(() => {\r\n                        console.log('Like removed');\r\n                    }).then(() => {\r\n                        return tx.complete;\r\n                    })\r\n            })\r\n        })\r\n    }\r\n}"]}